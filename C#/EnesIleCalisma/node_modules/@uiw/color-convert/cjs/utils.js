"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validHex = exports.equalHex = exports.equalColorString = exports.equalColorObjects = void 0;
var _ = require("./");
var equalColorObjects = function equalColorObjects(first, second) {
  if (first === second) return true;
  for (var prop in first) {
    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)
    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)
    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,
    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if
    // there is or not), and then as a type TS can iterate over.
    if (first[prop] !== second[prop]) return false;
  }
  return true;
};
exports.equalColorObjects = equalColorObjects;
var equalColorString = function equalColorString(first, second) {
  return first.replace(/\s/g, '') === second.replace(/\s/g, '');
};
exports.equalColorString = equalColorString;
var equalHex = function equalHex(first, second) {
  if (first.toLowerCase() === second.toLowerCase()) return true;

  // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects
  return equalColorObjects((0, _.hexToRgba)(first), (0, _.hexToRgba)(second));
};
exports.equalHex = equalHex;
var validHex = function validHex(hex) {
  return /^#?([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);
};
exports.validHex = validHex;
//# sourceMappingURL=utils.js.map